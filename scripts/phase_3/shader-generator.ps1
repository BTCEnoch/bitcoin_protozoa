# Shader Generator
#
# This script creates a tool to generate and compile shader code for visual effects
# in the Bitcoin Protozoa project. It allows developers to create and preview
# custom shaders for particle effects.
#
# Features:
# - Creates a React component for generating and previewing shaders
# - Implements shader compilation and validation
# - Provides a UI for editing and previewing shaders
# - Integrates with the trait system for applying shaders to particles
# - Supports different shader types (vertex, fragment, compute)

# Import the fixed component template
. "$PSScriptRoot\component-template-fixed.ps1"

# Configuration
$dataPath = "src\domains\trait\data"
$shaderDataPath = "$dataPath\shaderEffects.ts"

# Create the ShaderGenerator component
New-Component -componentName "ShaderGenerator" -domainPath "src\domains\trait" -description "A component for generating and compiling shader code for visual effects" -useGlobalCss

# Create the shader effects data file
$shaderEffectsContent = @"
/**
 * Shader Effects
 *
 * This file contains shader effect definitions for particle visual effects.
 * Each effect has parameters that can be used to create a Three.js shader material.
 *
 * IMPORTANT: This file is auto-generated. Do not edit directly.
 * Generated by shader-generator.ps1
 */

/**
 * Shader parameter interface
 */
export interface ShaderParameter {
  name: string;
  type: 'float' | 'int' | 'vec2' | 'vec3' | 'vec4' | 'color' | 'texture';
  defaultValue: any;
  min?: number;
  max?: number;
  description: string;
}

/**
 * Shader effect interface
 */
export interface ShaderEffect {
  id: string;
  name: string;
  description: string;
  category: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'mythic';
  vertexShader: string;
  fragmentShader: string;
  parameters: ShaderParameter[];
  preview?: string; // Base64 encoded preview image
}

/**
 * Shader categories
 */
export const SHADER_CATEGORIES = [
  'Glow',
  'Pulse',
  'Wave',
  'Noise',
  'Particle',
  'Holographic',
  'Crystalline',
  'Liquid',
  'Fire',
  'Electric'
];

/**
 * Shader effects
 */
export const SHADER_EFFECTS: Record<string, ShaderEffect> = {
  // Basic glow effect
  basicGlow: {
    id: 'basicGlow',
    name: 'Basic Glow',
    description: 'A simple glow effect that makes particles emit light',
    category: 'Glow',
    rarity: 'common',
    vertexShader: \`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    \`,
    fragmentShader: \`
      uniform vec3 color;
      uniform float intensity;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, dist);
        gl_FragColor = vec4(color * intensity, alpha);
      }
    \`,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 1.0, g: 0.8, b: 0.2 },
        description: 'The color of the glow effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.5,
        min: 0.0,
        max: 5.0,
        description: 'The intensity of the glow effect'
      }
    ]
  },

  // Pulsating effect
  pulsate: {
    id: 'pulsate',
    name: 'Pulsate',
    description: 'A pulsating effect that makes particles throb with energy',
    category: 'Pulse',
    rarity: 'uncommon',
    vertexShader: \`
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    \`,
    fragmentShader: \`
      uniform vec3 color;
      uniform float intensity;
      uniform float time;
      uniform float frequency;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float pulse = 0.5 + 0.5 * sin(time * frequency);
        float alpha = smoothstep(0.5 * pulse, 0.0, dist);
        gl_FragColor = vec4(color * intensity * (0.7 + 0.3 * pulse), alpha);
      }
    \`,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 0.2, g: 0.6, b: 1.0 },
        description: 'The color of the pulse effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.2,
        min: 0.0,
        max: 3.0,
        description: 'The intensity of the pulse effect'
      },
      {
        name: 'frequency',
        type: 'float',
        defaultValue: 2.0,
        min: 0.1,
        max: 10.0,
        description: 'The frequency of the pulse effect'
      }
    ]
  },

  // Wave distortion effect
  waveDistortion: {
    id: 'waveDistortion',
    name: 'Wave Distortion',
    description: 'A wave distortion effect that makes particles ripple',
    category: 'Wave',
    rarity: 'rare',
    vertexShader: \`
      varying vec2 vUv;
      uniform float time;
      uniform float amplitude;
      uniform float frequency;

      void main() {
        vUv = uv;
        vec3 pos = position;
        pos.x += sin(pos.y * frequency + time) * amplitude;
        pos.y += sin(pos.x * frequency + time) * amplitude;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    \`,
    fragmentShader: \`
      uniform vec3 color;
      uniform float intensity;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, dist);
        gl_FragColor = vec4(color * intensity, alpha);
      }
    \`,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 0.0, g: 1.0, b: 0.7 },
        description: 'The color of the wave effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.0,
        min: 0.0,
        max: 3.0,
        description: 'The intensity of the wave effect'
      },
      {
        name: 'amplitude',
        type: 'float',
        defaultValue: 0.1,
        min: 0.0,
        max: 0.5,
        description: 'The amplitude of the wave effect'
      },
      {
        name: 'frequency',
        type: 'float',
        defaultValue: 5.0,
        min: 0.1,
        max: 20.0,
        description: 'The frequency of the wave effect'
      }
    ]
  }
};

/**
 * Get a shader effect by ID
 */
export function getShaderEffect(id: string): ShaderEffect {
  return SHADER_EFFECTS[id] || SHADER_EFFECTS.basicGlow;
}

/**
 * Get all shader effects
 */
export function getAllShaderEffects(): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS);
}

/**
 * Get shader effects by category
 */
export function getShaderEffectsByCategory(category: string): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS).filter(effect => effect.category === category);
}

/**
 * Get shader effects by rarity
 */
export function getShaderEffectsByRarity(rarity: string): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS).filter(effect => effect.rarity === rarity);
}
"@

# Create the shader utility file
$shaderUtilPath = "$dataPath\shaderUtils.ts"
$shaderUtilContent = @"
/**
 * Shader Utilities
 *
 * This file contains utility functions for working with shaders in the Bitcoin Protozoa project.
 *
 * IMPORTANT: This file is auto-generated. Do not edit directly.
 * Generated by shader-generator.ps1
 */
import * as THREE from 'three';
import { ShaderEffect, ShaderParameter } from './shaderEffects';

/**
 * Create a shader material from a shader effect
 */
export function createShaderMaterial(effect: ShaderEffect, parameters: Record<string, any> = {}): THREE.ShaderMaterial {
  // Create uniforms object
  const uniforms: Record<string, THREE.IUniform> = {
    time: { value: 0 }
  };

  // Add effect parameters as uniforms
  effect.parameters.forEach(param => {
    const value = parameters[param.name] !== undefined ? parameters[param.name] : param.defaultValue;
    uniforms[param.name] = { value };
  });

  // Create shader material
  return new THREE.ShaderMaterial({
    uniforms,
    vertexShader: effect.vertexShader,
    fragmentShader: effect.fragmentShader,
    transparent: true,
    depthWrite: false,
    depthTest: true
  });
}

/**
 * Update shader material uniforms
 */
export function updateShaderUniforms(material: THREE.ShaderMaterial, time: number, parameters: Record<string, any> = {}): void {
  if (material.uniforms.time) {
    material.uniforms.time.value = time;
  }

  // Update other uniforms
  Object.entries(parameters).forEach(([key, value]) => {
    if (material.uniforms[key]) {
      material.uniforms[key].value = value;
    }
  });
}

/**
 * Create a parameter control component for a shader parameter
 */
export function createParameterControl(param: ShaderParameter, value: any, onChange: (value: any) => void): JSX.Element {
  switch (param.type) {
    case 'float':
    case 'int':
      return (
        <div key={param.name} className="shader-parameter">
          <label>{param.name}</label>
          <input
            type="range"
            min={param.min || 0}
            max={param.max || 1}
            step={param.type === 'float' ? 0.01 : 1}
            value={value}
            onChange={(e) => onChange(parseFloat(e.target.value))}
          />
          <span>{value.toFixed(2)}</span>
        </div>
      );

    case 'color':
      return (
        <div key={param.name} className="shader-parameter">
          <label>{param.name}</label>
          <input
            type="color"
            value={rgbToHex(value.r, value.g, value.b)}
            onChange={(e) => {
              const { r, g, b } = hexToRgb(e.target.value);
              onChange({ r, g, b });
            }}
          />
        </div>
      );

    default:
      return null;
  }
}

/**
 * Convert RGB to hex color
 */
function rgbToHex(r: number, g: number, b: number): string {
  const toHex = (c: number) => {
    const hex = Math.round(c * 255).toString(16);
    return hex.length === 1 ? '0' + hex : hex;
  };

  return \`#\${toHex(r)}\${toHex(g)}\${toHex(b)}\`;
}

/**
 * Convert hex color to RGB
 */
function hexToRgb(hex: string): { r: number, g: number, b: number } {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16) / 255,
    g: parseInt(result[2], 16) / 255,
    b: parseInt(result[3], 16) / 255
  } : { r: 0, g: 0, b: 0 };
}
"@

# Ensure the data directory exists
New-DirectoryIfNotExists -path $dataPath

# Save the data files
Set-Content -Path $shaderDataPath -Value $shaderEffectsContent -Force
Set-Content -Path $shaderUtilPath -Value $shaderUtilContent -Force

Write-Host "Created shader effects data file at $shaderDataPath" -ForegroundColor Green
Write-Host "Created shader utilities file at $shaderUtilPath" -ForegroundColor Green
Write-Host "Shader Generator script completed successfully!" -ForegroundColor Green
