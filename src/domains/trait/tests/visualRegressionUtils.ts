/**
 * Visual Regression Utilities
 *
 * This file contains utility functions for visual regression testing of particle traits.
 *
 * IMPORTANT: This file is auto-generated. Do not edit directly.
 * Generated by visual-regression-testing.ps1
 */
import * as THREE from 'three';
import { VisualTestCase } from '../data/visualTestCases';
import { getShape } from '../data/particleShapes';
import { getShaderEffect, createShaderMaterial } from '../data/shaderUtils';

/**
 * Visual test result interface
 */
export interface VisualTestResult {
  testCase: VisualTestCase;
  passed: boolean;
  diffPercentage: number;
  currentImage: string; // Base64 encoded current image
  diffImage?: string; // Base64 encoded diff image
  error?: string;
}

/**
 * Create a test renderer for visual regression testing
 */
export function createTestRenderer(width: number = 256, height: number = 256): THREE.WebGLRenderer {
  const renderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true,
    preserveDrawingBuffer: true
  });
  
  renderer.setSize(width, height);
  renderer.setClearColor(0x000000, 0);
  
  return renderer;
}

/**
 * Create a test scene for a visual test case
 */
export function createTestScene(testCase: VisualTestCase): THREE.Scene {
  const scene = new THREE.Scene();
  
  // Add ambient light
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  
  // Add directional light
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
  directionalLight.position.set(1, 1, 1);
  scene.add(directionalLight);
  
  // Create geometry based on shape
  const shapeDefinition = getShape(testCase.shape);
  let geometry: THREE.BufferGeometry;
  
  switch (testCase.shape.toLowerCase()) {
    case 'sphere':
      geometry = new THREE.SphereGeometry(
        shapeDefinition.parameters.radius as number,
        shapeDefinition.parameters.widthSegments as number,
        shapeDefinition.parameters.heightSegments as number
      );
      break;
    case 'cube':
      geometry = new THREE.BoxGeometry(
        shapeDefinition.parameters.width as number,
        shapeDefinition.parameters.height as number,
        shapeDefinition.parameters.depth as number
      );
      break;
    case 'cylinder':
      geometry = new THREE.CylinderGeometry(
        shapeDefinition.parameters.radiusTop as number,
        shapeDefinition.parameters.radiusBottom as number,
        shapeDefinition.parameters.height as number,
        shapeDefinition.parameters.radialSegments as number,
        shapeDefinition.parameters.heightSegments as number
      );
      break;
    case 'cone':
      geometry = new THREE.ConeGeometry(
        shapeDefinition.parameters.radius as number,
        shapeDefinition.parameters.height as number,
        shapeDefinition.parameters.radialSegments as number,
        shapeDefinition.parameters.heightSegments as number
      );
      break;
    case 'dodecahedron':
      geometry = new THREE.DodecahedronGeometry(
        shapeDefinition.parameters.radius as number,
        shapeDefinition.parameters.detail as number
      );
      break;
    default:
      geometry = new THREE.SphereGeometry(1, 32, 32);
  }
  
  // Create material based on test case
  let material: THREE.Material;
  
  if (testCase.shaderEffect) {
    const shaderEffect = getShaderEffect(testCase.shaderEffect);
    material = createShaderMaterial(shaderEffect, testCase.parameters);
  } else {
    const color = new THREE.Color(testCase.color.r, testCase.color.g, testCase.color.b);
    
    switch (testCase.role) {
      case 'CORE':
        material = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.5,
          roughness: 0.3,
          metalness: 0.7
        });
        break;
      case 'CONTROL':
        material = new THREE.MeshPhysicalMaterial({
          color,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          roughness: 0.5,
          metalness: 0.2
        });
        break;
      case 'MOVEMENT':
        material = new THREE.MeshStandardMaterial({
          color,
          roughness: 0.7,
          metalness: 0.1
        });
        break;
      case 'DEFENSE':
        material = new THREE.MeshPhysicalMaterial({
          color,
          roughness: 0.2,
          metalness: 0.8,
          reflectivity: 1.0
        });
        break;
      case 'ATTACK':
        material = new THREE.MeshStandardMaterial({
          color,
          emissive: color,
          emissiveIntensity: 0.8,
          roughness: 0.4,
          metalness: 0.6
        });
        break;
      default:
        material = new THREE.MeshStandardMaterial({ color });
    }
  }
  
  // Create mesh and add to scene
  const mesh = new THREE.Mesh(geometry, material);
  scene.add(mesh);
  
  return scene;
}

/**
 * Create a test camera for visual regression testing
 */
export function createTestCamera(): THREE.PerspectiveCamera {
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
  camera.position.set(0, 0, 3);
  camera.lookAt(0, 0, 0);
  
  return camera;
}

/**
 * Render a test case and return the image as a base64 string
 */
export function renderTestCase(
  testCase: VisualTestCase,
  renderer: THREE.WebGLRenderer,
  width: number = 256,
  height: number = 256
): string {
  const scene = createTestScene(testCase);
  const camera = createTestCamera();
  
  // Render the scene
  renderer.setSize(width, height);
  renderer.render(scene, camera);
  
  // Get the image data
  const imageData = renderer.domElement.toDataURL('image/png');
  
  return imageData;
}

/**
 * Compare two images and return the difference percentage
 */
export function compareImages(image1: string, image2: string): { diffPercentage: number, diffImage?: string } {
  // In a real implementation, this would use a library like pixelmatch or resemble.js
  // For now, we'll just return a placeholder
  return {
    diffPercentage: 0,
    diffImage: undefined
  };
}

/**
 * Run a visual regression test for a test case
 */
export async function runVisualTest(testCase: VisualTestCase, renderer: THREE.WebGLRenderer): Promise<VisualTestResult> {
  try {
    // Render the current image
    const currentImage = renderTestCase(testCase, renderer);
    
    // If there's no reference image, we can't compare
    if (!testCase.referenceImage) {
      return {
        testCase,
        passed: true,
        diffPercentage: 0,
        currentImage,
        error: 'No reference image available'
      };
    }
    
    // Compare the images
    const { diffPercentage, diffImage } = compareImages(currentImage, testCase.referenceImage);
    
    // Determine if the test passed (threshold of 0.1%)
    const passed = diffPercentage < 0.1;
    
    return {
      testCase,
      passed,
      diffPercentage,
      currentImage,
      diffImage
    };
  } catch (error) {
    return {
      testCase,
      passed: false,
      diffPercentage: 100,
      currentImage: '',
      error: error.message
    };
  }
}

/**
 * Run visual regression tests for multiple test cases
 */
export async function runVisualTests(testCases: VisualTestCase[], renderer: THREE.WebGLRenderer): Promise<VisualTestResult[]> {
  const results: VisualTestResult[] = [];
  
  for (const testCase of testCases) {
    const result = await runVisualTest(testCase, renderer);
    results.push(result);
  }
  
  return results;
}

/**
 * Generate a report from visual test results
 */
export function generateVisualTestReport(results: VisualTestResult[]): string {
  const totalTests = results.length;
  const passedTests = results.filter(result => result.passed).length;
  const failedTests = totalTests - passedTests;
  
  let report = \# Visual Regression Test Report\n\n\;
  report += \- Total Tests: \\n\;
  report += \- Passed Tests: \\n\;
  report += \- Failed Tests: \\n\n\;
  
  if (failedTests > 0) {
    report += \## Failed Tests\n\n\;
    
    results.filter(result => !result.passed).forEach(result => {
      report += \### \\n\n\;
      report += \- ID: \\n\;
      report += \- Description: \\n\;
      report += \- Diff Percentage: \%\n\;
      
      if (result.error) {
        report += \- Error: \\n\;
      }
      
      report += \\n\;
    });
  }
  
  return report;
}
