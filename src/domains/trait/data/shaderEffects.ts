/**
 * Shader Effects
 *
 * This file contains shader effect definitions for particle visual effects.
 * Each effect has parameters that can be used to create a Three.js shader material.
 *
 * IMPORTANT: This file is auto-generated. Do not edit directly.
 * Generated by shader-generator.ps1
 */

/**
 * Shader parameter interface
 */
export interface ShaderParameter {
  name: string;
  type: 'float' | 'int' | 'vec2' | 'vec3' | 'vec4' | 'color' | 'texture';
  defaultValue: any;
  min?: number;
  max?: number;
  description: string;
}

/**
 * Shader effect interface
 */
export interface ShaderEffect {
  id: string;
  name: string;
  description: string;
  category: string;
  rarity: 'common' | 'uncommon' | 'rare' | 'epic' | 'legendary' | 'mythic';
  vertexShader: string;
  fragmentShader: string;
  parameters: ShaderParameter[];
  preview?: string; // Base64 encoded preview image
}

/**
 * Shader categories
 */
export const SHADER_CATEGORIES = [
  'Glow',
  'Pulse',
  'Wave',
  'Noise',
  'Particle',
  'Holographic',
  'Crystalline',
  'Liquid',
  'Fire',
  'Electric'
];

/**
 * Shader effects
 */
export const SHADER_EFFECTS: Record<string, ShaderEffect> = {
  // Basic glow effect
  basicGlow: {
    id: 'basicGlow',
    name: 'Basic Glow',
    description: 'A simple glow effect that makes particles emit light',
    category: 'Glow',
    rarity: 'common',
    vertexShader: \
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    \,
    fragmentShader: \
      uniform vec3 color;
      uniform float intensity;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, dist);
        gl_FragColor = vec4(color * intensity, alpha);
      }
    \,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 1.0, g: 0.8, b: 0.2 },
        description: 'The color of the glow effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.5,
        min: 0.0,
        max: 5.0,
        description: 'The intensity of the glow effect'
      }
    ]
  },

  // Pulsating effect
  pulsate: {
    id: 'pulsate',
    name: 'Pulsate',
    description: 'A pulsating effect that makes particles throb with energy',
    category: 'Pulse',
    rarity: 'uncommon',
    vertexShader: \
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    \,
    fragmentShader: \
      uniform vec3 color;
      uniform float intensity;
      uniform float time;
      uniform float frequency;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float pulse = 0.5 + 0.5 * sin(time * frequency);
        float alpha = smoothstep(0.5 * pulse, 0.0, dist);
        gl_FragColor = vec4(color * intensity * (0.7 + 0.3 * pulse), alpha);
      }
    \,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 0.2, g: 0.6, b: 1.0 },
        description: 'The color of the pulse effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.2,
        min: 0.0,
        max: 3.0,
        description: 'The intensity of the pulse effect'
      },
      {
        name: 'frequency',
        type: 'float',
        defaultValue: 2.0,
        min: 0.1,
        max: 10.0,
        description: 'The frequency of the pulse effect'
      }
    ]
  },

  // Wave distortion effect
  waveDistortion: {
    id: 'waveDistortion',
    name: 'Wave Distortion',
    description: 'A wave distortion effect that makes particles ripple',
    category: 'Wave',
    rarity: 'rare',
    vertexShader: \
      varying vec2 vUv;
      uniform float time;
      uniform float amplitude;
      uniform float frequency;

      void main() {
        vUv = uv;
        vec3 pos = position;
        pos.x += sin(pos.y * frequency + time) * amplitude;
        pos.y += sin(pos.x * frequency + time) * amplitude;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
      }
    \,
    fragmentShader: \
      uniform vec3 color;
      uniform float intensity;
      varying vec2 vUv;

      void main() {
        float dist = length(vUv - vec2(0.5));
        float alpha = smoothstep(0.5, 0.0, dist);
        gl_FragColor = vec4(color * intensity, alpha);
      }
    \,
    parameters: [
      {
        name: 'color',
        type: 'color',
        defaultValue: { r: 0.0, g: 1.0, b: 0.7 },
        description: 'The color of the wave effect'
      },
      {
        name: 'intensity',
        type: 'float',
        defaultValue: 1.0,
        min: 0.0,
        max: 3.0,
        description: 'The intensity of the wave effect'
      },
      {
        name: 'amplitude',
        type: 'float',
        defaultValue: 0.1,
        min: 0.0,
        max: 0.5,
        description: 'The amplitude of the wave effect'
      },
      {
        name: 'frequency',
        type: 'float',
        defaultValue: 5.0,
        min: 0.1,
        max: 20.0,
        description: 'The frequency of the wave effect'
      }
    ]
  }
};

/**
 * Get a shader effect by ID
 */
export function getShaderEffect(id: string): ShaderEffect {
  return SHADER_EFFECTS[id] || SHADER_EFFECTS.basicGlow;
}

/**
 * Get all shader effects
 */
export function getAllShaderEffects(): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS);
}

/**
 * Get shader effects by category
 */
export function getShaderEffectsByCategory(category: string): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS).filter(effect => effect.category === category);
}

/**
 * Get shader effects by rarity
 */
export function getShaderEffectsByRarity(rarity: string): ShaderEffect[] {
  return Object.values(SHADER_EFFECTS).filter(effect => effect.rarity === rarity);
}
